---
phase: 02-single-session-pty-wrapper
plan: 02
type: tdd
wave: 2
depends_on: [02-01]
files_modified:
  - src/ProcessSupervisor.ts
  - test/ProcessSupervisor.test.ts
autonomous: true
requirements: [INFR-01, INFR-02, RESM-01, RESM-02]

must_haves:
  truths:
    - "Running the tool spawns Claude Code in a real PTY via node-pty and all output appears in the user's terminal"
    - "User keystrokes are forwarded to the PTY during RUNNING state and discarded during WAITING state"
    - "When the rate limit is detected, the Scheduler is called with the parsed reset time"
    - "When the Scheduler fires, the resume sequence (Escape + 'continue' + Enter) is sent to the PTY"
    - "The four-state machine (RUNNING -> LIMIT_DETECTED -> WAITING -> RESUMING -> RUNNING) transitions correctly"
    - "Post-resume cooldown suppresses false-positive re-detections for 30 seconds"
    - "Terminal resize events are forwarded to the PTY to keep dimensions in sync"
    - "On PTY exit, process.stdin.unref() is called to allow clean Node.js exit"
  artifacts:
    - path: "src/ProcessSupervisor.ts"
      provides: "Four-state PTY orchestrator with passthrough, detection, and auto-resume"
      exports: ["ProcessSupervisor", "SessionState"]
      min_lines: 80
    - path: "test/ProcessSupervisor.test.ts"
      provides: "State machine unit tests with mocked node-pty"
      min_lines: 100
  key_links:
    - from: "src/ProcessSupervisor.ts"
      to: "src/PatternDetector.ts"
      via: "detector.on('limit', handler) + detector.feed(data) + detector.reset()"
      pattern: "this\\.#detector\\.(feed|on|reset)"
    - from: "src/ProcessSupervisor.ts"
      to: "src/Scheduler.ts"
      via: "scheduler.scheduleAt(resetTime, callback) + scheduler.cancel()"
      pattern: "this\\.#scheduler\\.(scheduleAt|cancel)"
    - from: "src/ProcessSupervisor.ts"
      to: "src/StdinWriter.ts"
      via: "writer.write(data) for resume sequence + writer.markDead() on exit"
      pattern: "this\\.#writer\\.(write|markDead)"
    - from: "src/ProcessSupervisor.ts"
      to: "node-pty"
      via: "spawnFn() call to create IPty instance"
      pattern: "this\\.#spawnFn\\("
---

<objective>
Create ProcessSupervisor, the four-state orchestrator that spawns Claude Code via node-pty, transparently passes I/O, detects rate limits via PatternDetector, waits via Scheduler, and resumes via StdinWriter.

Purpose: This is the core of Phase 2 — the single-session PTY wrapper. It assembles the three Phase 1 modules (PatternDetector, Scheduler, config) with the new StdinWriter into a state machine that automates the detect-wait-resume cycle.

Output: `src/ProcessSupervisor.ts` with full test coverage via TDD using mocked node-pty
</objective>

<execution_context>
@/Users/dakmor/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dakmor/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-single-session-pty-wrapper/02-RESEARCH.md
@.planning/phases/02-single-session-pty-wrapper/02-01-SUMMARY.md

<interfaces>
<!-- Key types and contracts the executor needs. Extracted from Phase 1 codebase + Plan 01 output. -->

From src/PatternDetector.ts:
```typescript
export interface LimitEvent {
  resetTime: Date | null;
  rawMatch: string;
}

export interface PatternDetectorOptions {
  pattern?: RegExp;
  debug?: boolean;
}

export class PatternDetector extends EventEmitter {
  constructor(options?: PatternDetectorOptions);
  feed(rawChunk: string): void;    // strips ANSI, appends to rolling buffer, tests pattern
  reset(): void;                    // clears buffer + re-arms detection
  // Emits: 'limit' event with LimitEvent payload
}
```

From src/Scheduler.ts:
```typescript
export class Scheduler {
  constructor(safetyMs?: number);    // default 5000ms
  scheduleAt(resetTime: Date | null, callback: () => void): void;
  cancel(): void;                    // sticky — makes scheduler inert
}
```

From src/StdinWriter.ts (created in Plan 01):
```typescript
export class StdinWriter {
  constructor(ptyProcess: IPty);
  write(data: string): void;    // EPIPE-safe, no-op if dead
  markDead(): void;              // called from onExit handler
  get isDead(): boolean;
}
```

From node-pty (external):
```typescript
interface IPty {
  onData(listener: (data: string) => void): IDisposable;
  onExit(listener: (e: { exitCode: number; signal?: number }) => void): IDisposable;
  write(data: string): void;
  resize(columns: number, rows: number): void;
  kill(signal?: string): void;
  pid: number;
  cols: number;
  rows: number;
  process: string;
}

function spawn(file: string, args: string[], options: IPtyForkOptions): IPty;
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create failing ProcessSupervisor tests (RED)</name>
  <files>test/ProcessSupervisor.test.ts</files>
  <action>
Create `test/ProcessSupervisor.test.ts` with tests for the four-state machine. All tests use a mock node-pty via dependency injection (constructor accepts optional `spawnFn` parameter — avoids `vi.mock()` module-level magic).

**Mock factory:** Create a `makeMockPty()` helper that returns a mock IPty with:
- `onData: vi.fn()` — stores the callback so tests can simulate PTY output
- `onExit: vi.fn()` — stores the callback so tests can simulate PTY exit
- `write: vi.fn()`
- `resize: vi.fn()`
- `kill: vi.fn()`
- `pid: 9999`, `cols: 80`, `rows: 24`, `process: 'claude'`

Create a `getMockCallbacks(mockPty)` helper that extracts the stored `onData` and `onExit` callbacks from the mock's `onData.mock.calls[0][0]` and `onExit.mock.calls[0][0]`.

**Mocking stdin/stdout:** Use `vi.spyOn(process.stdout, 'write').mockImplementation(() => true)` and similar for process.stdin. Since process.stdin.setRawMode and process.stdin.on need mocking, consider creating a partial mock or skipping the raw-mode tests (ProcessSupervisor should guard with `process.stdin.isTTY` check — in test env, isTTY is false, so setRawMode is not called).

**Tests to write (at minimum 8):**

1. `starts in RUNNING state` — create supervisor, assert `supervisor.state === SessionState.RUNNING`

2. `spawn() calls spawnFn with correct arguments` — create supervisor with mock spawnFn, call spawn('claude', ['--continue']), assert spawnFn was called with file='claude', args=['--continue'], and options including cols, rows, cwd, env

3. `PTY output is written to process.stdout` — spawn, simulate onData('hello'), assert `process.stdout.write` was called with 'hello'

4. `PTY output feeds PatternDetector in RUNNING state` — spawn, simulate onData with rate-limit text, verify state transitions to WAITING (detector emits 'limit', supervisor transitions)

5. `transitions RUNNING -> LIMIT_DETECTED -> WAITING on rate-limit detection` — spawn, feed rate-limit text via onData, assert state is WAITING (LIMIT_DETECTED is transient — immediately transitions to WAITING after scheduling)

6. `transitions WAITING -> RESUMING -> RUNNING when Scheduler fires` — spawn, feed rate-limit text, advance fake timers past reset time, assert state returns to RUNNING

7. `sends Escape then "continue\r" during RESUMING transition` — spawn, feed rate-limit text, advance timers, assert mock pty.write was called with '\x1b' and then 'continue\r'

8. `suppresses re-detection during cooldown period` — spawn, feed rate-limit text, advance timers (resume fires), immediately feed rate-limit text again, assert state stays RUNNING (cooldown suppresses)

9. `PTY exit calls markDead on StdinWriter and cancels Scheduler` — spawn, simulate onExit, assert writer is dead, scheduler is cancelled. Note: mock process.exit to prevent test runner from exiting.

10. `does not feed detector during WAITING state` — spawn, trigger rate limit (enter WAITING), simulate more onData, assert that the new onData output goes to stdout but NOT to the detector (detector.feed is not called during WAITING). This can be verified by checking the state does not change despite receiving rate-limit text again.

Use `vi.useFakeTimers()` in beforeEach and `vi.useRealTimers()` in afterEach for all timer-dependent tests.

Import ProcessSupervisor and SessionState from `'../src/ProcessSupervisor.js'`.

Run `npm test` — all ProcessSupervisor tests should FAIL (module not found). The existing 35 tests (Phase 1 + StdinWriter) should still pass.

Commit: `test(02-02): add failing ProcessSupervisor state machine tests`
  </action>
  <verify>
    <automated>npm test 2>&1 | tail -30</automated>
  </verify>
  <done>8-10 ProcessSupervisor tests exist and fail. 35 existing tests still pass.</done>
</task>

<task type="auto">
  <name>Task 2: Implement ProcessSupervisor to pass all tests (GREEN)</name>
  <files>src/ProcessSupervisor.ts</files>
  <action>
Create `src/ProcessSupervisor.ts` implementing the four-state orchestrator.

**Key design decisions (from RESEARCH.md):**

1. **SessionState enum:** Export `const enum SessionState` with RUNNING, LIMIT_DETECTED, WAITING, RESUMING values.

2. **Constructor accepts optional `spawnFn`:** `constructor(options?: { spawnFn?: typeof pty.spawn; cooldownMs?: number; safetyMs?: number })`. Defaults: spawnFn = `require('node-pty').spawn`, cooldownMs = 30000, safetyMs = 5000. This enables dependency injection for testing without vi.mock().

3. **Expose `state` getter:** `get state(): SessionState` — returns `this.#state`. Required for tests and Phase 3 status display.

4. **spawn(command, args) method:**
   - Call `this.#spawnFn(command, args, { name: process.env.TERM ?? 'xterm-256color', cols: process.stdout.columns ?? 80, rows: process.stdout.rows ?? 24, cwd: process.cwd(), env: process.env as Record<string, string> })`
   - Create StdinWriter wrapping the IPty
   - Attach passthrough: `ptyProcess.onData(data => { process.stdout.write(data); if (this.#state === SessionState.RUNNING) this.#detector.feed(data); })`
   - Attach stdin forwarding (only if `process.stdin.isTTY`): set raw mode, listen for data, forward to writer only in RUNNING state
   - Attach resize handler: `process.stdout.on('resize', () => pty.resize(...))`
   - Attach onExit handler: mark writer dead, cancel scheduler, call `process.stdin.unref()`, call `process.exit(exitCode ?? 0)` — but guard process.exit behind a `this.#onExit` callback so tests can override it

5. **#onLimitDetected(event) private method:**
   - Guard: `if (Date.now() < this.#cooldownUntil) return;`
   - Set state to LIMIT_DETECTED
   - Log to stderr: `[SessionState] LIMIT_DETECTED (resets: ...)`
   - Call `this.#scheduler.scheduleAt(event.resetTime, () => this.#onResumeReady())`
   - Set state to WAITING
   - Log to stderr: `[SessionState] WAITING`

6. **#onResumeReady() private method:**
   - Set state to RESUMING
   - Log to stderr: `[SessionState] RESUMING`
   - `this.#writer.write('\x1b')` — Escape to dismiss rate-limit UI
   - `this.#writer.write('continue\r')` — type "continue" and press Enter
   - Set `this.#cooldownUntil = Date.now() + this.#cooldownMs`
   - `this.#detector.reset()` — re-arm for next detection
   - Set state to RUNNING
   - Log to stderr: `[SessionState] RUNNING`

7. **shutdown() method:** Cancel scheduler, mark writer dead, kill PTY.

**Important implementation notes:**
- Do NOT call `process.stdin.setRawMode(true)` if `!process.stdin.isTTY` (test environment has no TTY — setRawMode would throw)
- Use `process.stderr.write()` for state transition logs (not console.log — that goes to stdout and pollutes PTY passthrough)
- The `process.exit()` call in onExit should be overridable via constructor option `onExit?: (code: number) => void` defaulting to `process.exit`. This lets tests prevent actual process exit.

Run `npm test` — all tests should pass (Phase 1 + StdinWriter + ProcessSupervisor).
Run `npx tsc --noEmit` — should be clean.

Commit: `feat(02-02): implement ProcessSupervisor four-state PTY orchestrator`
  </action>
  <verify>
    <automated>npm test && npx tsc --noEmit</automated>
  </verify>
  <done>All tests pass (30 Phase 1 + 5 StdinWriter + 8-10 ProcessSupervisor). TypeScript compiles cleanly. ProcessSupervisor spawns PTY, passes I/O through, detects rate limits, waits, sends resume sequence, suppresses false positives via cooldown.</done>
</task>

</tasks>

<verification>
- `npm test` passes with all tests (30 Phase 1 + 5 StdinWriter + 8-10 ProcessSupervisor)
- `npx tsc --noEmit` is clean
- `src/ProcessSupervisor.ts` exports `ProcessSupervisor` class and `SessionState` enum
- State machine transitions: RUNNING -> LIMIT_DETECTED -> WAITING -> RESUMING -> RUNNING
- PTY output flows to process.stdout in all states
- PatternDetector.feed() is only called during RUNNING state
- Resume sequence sends '\x1b' then 'continue\r' via StdinWriter
- Cooldown prevents re-detection for 30 seconds after resume
- process.stdin.unref() called on PTY exit
- StdinWriter.markDead() called on PTY exit
</verification>

<success_criteria>
- INFR-01 covered: spawn() calls node-pty.spawn() with correct options (TERM, cols, rows, cwd, env)
- INFR-02 covered: onData pipes to process.stdout; stdin forwards to pty.write via StdinWriter
- RESM-01 covered: Scheduler.scheduleAt(resetTime) called when limit detected
- RESM-02 covered: '\x1b' + 'continue\r' sent to PTY when Scheduler fires
- All Phase 1 tests remain green (no regressions)
</success_criteria>

<output>
After completion, create `.planning/phases/02-single-session-pty-wrapper/02-02-SUMMARY.md`
</output>
