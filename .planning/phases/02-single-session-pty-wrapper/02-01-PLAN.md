---
phase: 02-single-session-pty-wrapper
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - package.json
  - src/StdinWriter.ts
  - test/StdinWriter.test.ts
autonomous: true
requirements: [RESM-04]

must_haves:
  truths:
    - "Calling pty.write() after PTY process exits does NOT throw an unhandled exception"
    - "EPIPE errors from pty.write() are caught and swallowed silently"
    - "Non-EPIPE write errors are logged to stderr but do not crash the process"
    - "After markDead(), all write() calls are silent no-ops"
  artifacts:
    - path: "src/StdinWriter.ts"
      provides: "EPIPE-safe PTY write wrapper"
      exports: ["StdinWriter"]
      min_lines: 15
    - path: "test/StdinWriter.test.ts"
      provides: "Unit tests for EPIPE guard behavior"
      min_lines: 40
  key_links:
    - from: "src/StdinWriter.ts"
      to: "node-pty IPty.write()"
      via: "try/catch wrapper around pty.write()"
      pattern: "this\\.#pty\\.write\\(data\\)"
---

<objective>
Create StdinWriter, an EPIPE-safe wrapper around node-pty's `pty.write()`. Install node-pty as a project dependency.

Purpose: RESM-04 requires that the tool handles EPIPE errors gracefully if Claude Code exits during the wait window. `StdinWriter` isolates this concern into a single 20-line class so ProcessSupervisor (Plan 02) never touches `pty.write()` directly.

Output: `src/StdinWriter.ts` with full test coverage via TDD, `node-pty` added to package.json
</objective>

<execution_context>
@/Users/dakmor/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dakmor/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-single-session-pty-wrapper/02-RESEARCH.md

<interfaces>
<!-- Key types the executor needs. Extracted from Phase 1 codebase + node-pty typings. -->

From node-pty (external dependency — IPty interface):
```typescript
// node-pty v1.1.0 — the write() method is the only one StdinWriter wraps
interface IPty {
  write(data: string): void;
  // ... other methods not relevant to StdinWriter
}
```

Note: StdinWriter uses `import type * as pty from 'node-pty'` for the IPty type only.
The actual IPty instance is passed via constructor injection.
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install node-pty and create failing StdinWriter tests (RED)</name>
  <files>package.json, test/StdinWriter.test.ts</files>
  <action>
1. Install node-pty as a production dependency:
   ```bash
   npm install node-pty
   ```
   This adds `"node-pty": "^1.1.0"` to package.json dependencies. node-pty is a native module — it ships prebuilt binaries for macOS/Linux. If prebuilts are unavailable, it falls back to node-gyp (requires Xcode CLI tools on macOS, already present in any Node dev env).

2. Create `test/StdinWriter.test.ts` with the following tests (all should FAIL because src/StdinWriter.ts does not exist yet):

   **Mock factory:** Create a `makeMockPty()` helper that returns a mock IPty object with `write: vi.fn()` and all other required IPty properties as stubs. Cast as `unknown as pty.IPty` to satisfy TypeScript.

   **Tests to write (5 total):**
   - `forwards writes to the PTY` — create StdinWriter with mock, call write('hello'), assert mock.write called with 'hello'
   - `is a no-op after markDead()` — create writer, call markDead(), call write('hello'), assert mock.write NOT called
   - `catches EPIPE errors without throwing` — mock write to throw `Object.assign(new Error('write EPIPE'), { code: 'EPIPE' })`, call writer.write('hello'), assert no throw
   - `logs non-EPIPE errors to stderr` — mock write to throw `Object.assign(new Error('EBADF'), { code: 'EBADF' })`, spy on `process.stderr.write`, call writer.write('hello'), assert stderr spy was called, restore spy
   - `exposes isDead getter` — create writer, assert isDead is false, call markDead(), assert isDead is true

   Import StdinWriter from `'../src/StdinWriter.js'` (CJS project convention — .js extension in imports).

3. Run `npm test` — all 5 StdinWriter tests should FAIL (module not found). The existing 30 Phase 1 tests should still pass.

4. Commit: `test(02-01): add failing StdinWriter tests`
  </action>
  <verify>
    <automated>npm test 2>&1 | tail -20</automated>
  </verify>
  <done>5 StdinWriter tests exist and fail. 30 Phase 1 tests still pass. node-pty is in package.json dependencies.</done>
</task>

<task type="auto">
  <name>Task 2: Implement StdinWriter to pass all tests (GREEN)</name>
  <files>src/StdinWriter.ts</files>
  <action>
Create `src/StdinWriter.ts` implementing the EPIPE-safe write wrapper:

```typescript
import type * as pty from 'node-pty';

export class StdinWriter {
  readonly #pty: pty.IPty;
  #dead = false;

  constructor(ptyProcess: pty.IPty) {
    this.#pty = ptyProcess;
  }

  write(data: string): void {
    if (this.#dead) return;
    try {
      this.#pty.write(data);
    } catch (err: unknown) {
      const code = (err as NodeJS.ErrnoException).code;
      if (code !== 'EPIPE') {
        process.stderr.write(`[StdinWriter] write error: ${code ?? String(err)}\n`);
      }
      // EPIPE = PTY process exited between dead-check and write — silently ignore
    }
  }

  markDead(): void {
    this.#dead = true;
  }

  get isDead(): boolean {
    return this.#dead;
  }
}
```

Key implementation notes:
- Use `import type * as pty from 'node-pty'` (type-only import — no runtime node-pty load in this file)
- Private class fields (#pty, #dead) for encapsulation — consistent with Phase 1 pattern
- `write()` checks #dead first (fast path), then try/catch around pty.write()
- EPIPE is silently swallowed; all other errors logged to stderr but NOT rethrown
- `markDead()` is called from ProcessSupervisor's onExit handler (Plan 02)

Run `npm test` — all 35 tests (30 Phase 1 + 5 StdinWriter) should pass.
Run `npx tsc --noEmit` — should be clean (no type errors).

Commit: `feat(02-01): implement StdinWriter EPIPE-safe write wrapper`
  </action>
  <verify>
    <automated>npm test && npx tsc --noEmit</automated>
  </verify>
  <done>All 35 tests pass (30 Phase 1 + 5 StdinWriter). TypeScript compiles cleanly. StdinWriter catches EPIPE, logs non-EPIPE to stderr, no-ops after markDead().</done>
</task>

</tasks>

<verification>
- `npm test` passes with 35 tests (30 Phase 1 + 5 StdinWriter)
- `npx tsc --noEmit` is clean
- `node-pty` appears in package.json dependencies
- `src/StdinWriter.ts` exports `StdinWriter` class
- Writing to a dead StdinWriter is a no-op (no error, no output)
- EPIPE from pty.write() does not propagate as unhandled exception
</verification>

<success_criteria>
- RESM-04 is fully covered: EPIPE errors from pty.write() are caught; dead-PTY writes are no-ops
- StdinWriter is ready for import by ProcessSupervisor in Plan 02
- node-pty is installed and importable
- All Phase 1 tests remain green (no regressions)
</success_criteria>

<output>
After completion, create `.planning/phases/02-single-session-pty-wrapper/02-01-SUMMARY.md`
</output>
