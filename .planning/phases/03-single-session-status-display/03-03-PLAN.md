---
phase: 03-single-session-status-display
plan: 03
type: execute
wave: 2
depends_on: [01, 02]
files_modified:
  - src/ProcessSupervisor.ts
  - src/cli.ts
  - test/ProcessSupervisor.test.ts
autonomous: true
requirements: [RESM-03]

must_haves:
  truths:
    - ProcessSupervisor emits 'stateChange' events with state and resetTime on every state transition
    - CLI entry point parses -- separator and passes arguments after it to Claude Code
    - cli.ts sets up scroll region, renders status bar, and registers cleanup handlers
    - Terminal resize re-initializes scroll region and re-renders status bar
    - Countdown timer ticks every second in WAITING state, stops on state change
    - Centered countdown card appears when entering WAITING state, clears on exit
    - Dead state shows red "Dead" for ~5 seconds then exits
    - Process exit resets scroll region and restores terminal
  artifacts:
    - src/ProcessSupervisor.ts (modified — adds EventEmitter, stateChange events)
    - src/cli.ts (new — entry point with display wiring)
  key_links:
    - cli.ts creates ProcessSupervisor, StatusBar, CountdownCard
    - cli.ts listens to ProcessSupervisor 'stateChange' events
    - cli.ts listens to 'resize' events on process.stdout
    - cli.ts writes StatusBar.render() output to process.stdout on each state change and countdown tick
---

<objective>
Wire ProcessSupervisor state events into the status display and create the CLI entry point.

Purpose: This plan integrates all pieces from Plans 01-02 into a working tool. ProcessSupervisor gets EventEmitter capabilities to broadcast state changes. The CLI entry point sets up the terminal scroll region, renders the status bar, manages the countdown timer, and handles cleanup on exit. The `--` separator enables passing arguments through to Claude Code.

Output: Modified `src/ProcessSupervisor.ts` with state events, new `src/cli.ts` entry point, updated tests.
</objective>

<execution_context>
@/Users/dakmor/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dakmor/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-single-session-status-display/03-RESEARCH.md
@.planning/phases/03-single-session-status-display/03-01-SUMMARY.md
@.planning/phases/03-single-session-status-display/03-02-SUMMARY.md

<interfaces>
From src/ProcessSupervisor.ts (current, to be modified):
```typescript
export const enum SessionState {
  RUNNING = 'RUNNING',
  LIMIT_DETECTED = 'LIMIT_DETECTED',
  WAITING = 'WAITING',
  RESUMING = 'RESUMING',
}

export class ProcessSupervisor {
  get state(): SessionState;
  spawn(command: string, args: string[]): void;
  shutdown(): void;
}
```

From src/StatusBar.ts (created in Plan 01):
```typescript
export class StatusBar {
  render(state: string, opts?: { resetTime?: Date; cwd?: string }): string;
  initScrollRegion(rows: number): string;
  cleanup(): string;
}
export function formatCountdown(resetTime: Date): string;
export function formatResetTime(resetTime: Date): string;
```

From src/CountdownCard.ts (created in Plan 02):
```typescript
export class CountdownCard {
  render(opts: { resetTime: Date | null; cwd: string }): string;
  clear(): string;
}
```

From src/ansi.ts (created in Plan 01):
```typescript
export const resetScrollRegion: string;
export const showCursor: string;
export const resetAttributes: string;
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add EventEmitter and state change events to ProcessSupervisor</name>
  <files>src/ProcessSupervisor.ts, test/ProcessSupervisor.test.ts</files>
  <action>
Modify ProcessSupervisor to extend EventEmitter and emit 'stateChange' events on every state transition.

**Changes to ProcessSupervisor:**

1. Make ProcessSupervisor extend EventEmitter:
   ```typescript
   import { EventEmitter } from 'events';
   export class ProcessSupervisor extends EventEmitter {
     constructor(options) {
       super();
       // ... existing constructor code
     }
   }
   ```

2. Add a private `#setState` helper that updates state AND emits:
   ```typescript
   #resetTime: Date | null = null;

   #setState(newState: SessionState): void {
     this.#state = newState;
     this.emit('stateChange', {
       state: newState,
       resetTime: this.#resetTime,
     });
   }
   ```

3. Replace all direct `this.#state = ...` assignments with `this.#setState(...)`:
   - In `#onLimitDetected`: store `event.resetTime` in `this.#resetTime`, then `#setState(LIMIT_DETECTED)`, then `#setState(WAITING)`
   - In `#onResumeReady`: `#setState(RESUMING)`, then after resume, `#setState(RUNNING)`, clear `this.#resetTime = null`

4. Add a 'dead' emission on PTY exit (before calling onExitCallback):
   ```typescript
   ptyProcess.onExit((e) => {
     this.#writer!.markDead();
     this.#scheduler.cancel();
     this.emit('stateChange', { state: 'DEAD', resetTime: null });
     // ... existing cleanup
   });
   ```

5. Replace `process.stderr.write('[SessionState]...')` debug lines with the #setState calls — the events replace the stderr logging.

6. Redirect PTY output through a method that the CLI can override:
   ```typescript
   /** Override to intercept PTY output before writing to stdout. Default: process.stdout.write */
   onOutput?: (data: string) => void;
   ```
   In the constructor, default `this.#onOutput = options.onOutput ?? ((data) => process.stdout.write(data))`. In ptyProcess.onData, call `this.#onOutput(data)` instead of direct `process.stdout.write(data)`.

**Update existing tests in test/ProcessSupervisor.test.ts:**
- Add test: supervisor emits 'stateChange' with LIMIT_DETECTED when limit detected
- Add test: supervisor emits 'stateChange' with WAITING after scheduling
- Add test: supervisor emits 'stateChange' with RESUMING then RUNNING on resume
- Add test: supervisor emits 'stateChange' with DEAD on PTY exit
- Add test: stateChange event includes resetTime when available
- Ensure all existing tests still pass (EventEmitter doesn't change external behavior)
  </action>
  <verify>
    <automated>npx vitest run test/ProcessSupervisor.test.ts</automated>
  </verify>
  <done>ProcessSupervisor emits stateChange events on all transitions. Existing tests pass. New event tests pass. resetTime is included in WAITING/LIMIT_DETECTED events.</done>
</task>

<task type="auto">
  <name>Task 2: Create CLI entry point with display wiring and -- argument parsing</name>
  <files>src/cli.ts</files>
  <action>
Create `src/cli.ts` — the main entry point that wires ProcessSupervisor to the status display.

**Argument parsing:**
```typescript
function parseArgs(argv: string[]): { claudeArgs: string[] } {
  // argv = process.argv (includes 'node' and script path)
  const userArgs = argv.slice(2); // strip node + script
  const separatorIdx = userArgs.indexOf('--');
  if (separatorIdx === -1) {
    return { claudeArgs: [] };
  }
  return { claudeArgs: userArgs.slice(separatorIdx + 1) };
}
```

**Main function:**
```typescript
function main(): void {
  const { claudeArgs } = parseArgs(process.argv);
  const cols = () => process.stdout.columns ?? 80;
  const rows = () => process.stdout.rows ?? 24;
  const cwd = process.cwd();

  // Create display components
  const statusBar = new StatusBar({ cols: cols() });
  const countdownCard = new CountdownCard({ cols: cols(), rows: rows() });

  // Set up terminal: scroll region leaves row 1 for status bar
  process.stdout.write(statusBar.initScrollRegion(rows()));

  // Initial status bar render
  process.stdout.write(statusBar.render('RUNNING', { cwd }));

  // Countdown timer handle
  let countdownInterval: ReturnType<typeof setInterval> | null = null;

  // Create supervisor with output redirected to scroll region
  const supervisor = new ProcessSupervisor({
    onOutput: (data) => process.stdout.write(data),
  });

  // Handle state changes
  supervisor.on('stateChange', ({ state, resetTime }) => {
    // Clear any existing countdown timer
    if (countdownInterval) {
      clearInterval(countdownInterval);
      countdownInterval = null;
    }

    if (state === 'DEAD') {
      // Show dead state, wait 5 seconds, then exit
      process.stdout.write(statusBar.render('DEAD', { cwd }));
      process.stdout.write(countdownCard.clear());
      setTimeout(() => {
        process.stdout.write(statusBar.cleanup());
        process.exit(0);
      }, 5000);
      return;
    }

    // Re-render status bar
    process.stdout.write(statusBar.render(state, { resetTime, cwd }));

    if (state === 'WAITING' && resetTime) {
      // Show countdown card
      process.stdout.write(countdownCard.render({ resetTime, cwd }));

      // Start 1-second countdown tick
      countdownInterval = setInterval(() => {
        // Check if still waiting (race protection)
        if (supervisor.state !== 'WAITING') {
          clearInterval(countdownInterval!);
          countdownInterval = null;
          return;
        }
        // Re-render status bar with updated countdown
        process.stdout.write(statusBar.render('WAITING', { resetTime, cwd }));
        // Re-render countdown card with updated countdown
        process.stdout.write(countdownCard.render({ resetTime, cwd }));
      }, 1000);
    } else {
      // Clear countdown card if it was showing
      process.stdout.write(countdownCard.clear());
    }
  });

  // Handle terminal resize
  process.stdout.on('resize', () => {
    // Update display components with new dimensions
    statusBar.cols = cols();
    countdownCard.cols = cols();
    countdownCard.rows = rows();

    // Re-initialize scroll region
    process.stdout.write(statusBar.initScrollRegion(rows()));

    // Re-render current state
    const currentState = supervisor.state as string;
    process.stdout.write(statusBar.render(currentState, { cwd }));
  });

  // Terminal cleanup on exit
  const cleanup = () => {
    if (countdownInterval) {
      clearInterval(countdownInterval);
    }
    process.stdout.write(statusBar.cleanup());
  };

  process.on('exit', cleanup);
  process.on('SIGINT', () => { cleanup(); process.exit(130); });
  process.on('SIGTERM', () => { cleanup(); process.exit(143); });

  // Spawn Claude Code with passed-through arguments
  supervisor.spawn('claude', claudeArgs);
}

main();
```

**Important details:**
- StatusBar and CountdownCard need mutable `cols`/`rows` properties for resize — add setters or make them public fields (adjust Plan 01/02 interfaces if needed by adding public setter methods `setDimensions(cols, rows)` or making the properties writable).
- The countdown interval recalculates from `resetTime - Date.now()` each tick (no drift — per research pitfall #3).
- State check in the interval callback prevents rendering after state has moved on (per research pitfall #4).
- Cleanup handler resets scroll region on every exit path (per research pitfall #1).
- The `onOutput` option in ProcessSupervisor constructor is used to route PTY output to the scroll region area (not row 1).
  </action>
  <verify>
    <automated>npx vitest run test/ProcessSupervisor.test.ts</automated>
    Note: cli.ts is integration-heavy (spawns real processes). Verification is primarily through ProcessSupervisor event tests (Task 1) and manual smoke test.
  </verify>
  <done>CLI entry point exists at src/cli.ts. Running `npx tsx src/cli.ts` shows a status bar at the top of the terminal. Running `npx tsx src/cli.ts -- --continue` passes --continue to Claude Code. Terminal cleanup restores scroll region on exit. Countdown timer ticks every second during WAITING state.</done>
</task>

</tasks>

<verification>
- `npx vitest run` — all tests pass (ansi, StatusBar, CountdownCard, ProcessSupervisor)
- `npx tsx src/cli.ts --help` or `npx tsx src/cli.ts` starts with visible status bar
- Terminal is restored to normal on Ctrl+C or process exit
- State transitions cause status bar color changes
</verification>

<success_criteria>
- ProcessSupervisor emits stateChange events with state + resetTime
- CLI entry point initializes scroll region and status bar
- -- separator passes arguments through to Claude Code
- Countdown timer ticks every second in WAITING state
- Centered countdown card shows during WAITING state
- Dead state shows red "Dead" for 5 seconds then exits
- Terminal cleanup runs on all exit paths (exit, SIGINT, SIGTERM)
- Resize updates scroll region and re-renders display
</success_criteria>

<output>
After completion, create `.planning/phases/03-single-session-status-display/03-03-SUMMARY.md`
</output>
