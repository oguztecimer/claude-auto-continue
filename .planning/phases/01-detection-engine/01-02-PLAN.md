---
phase: 01-detection-engine
plan: 02
type: tdd
wave: 2
depends_on:
  - 01-01
files_modified:
  - src/PatternDetector.ts
  - test/PatternDetector.test.ts
autonomous: true
requirements:
  - DETC-01
  - DETC-02
  - DETC-03
  - DETC-04
  - DETC-05
must_haves:
  truths:
    - "Detector emits 'limit' event when fed legacy pipe-delimited format: 'Claude AI usage limit reached|1760000400'"
    - "Detector emits 'limit' event when fed mid-era format: 'Claude usage limit reached. Your limit will reset at 3pm (America/Santiago).'"
    - "Detector emits 'limit' event when fed current format: 'You've hit your limit . resets 4pm (Europe/Berlin)'"
    - "Detector emits 'limit' event when fed current format with date: 'You've hit your limit . resets Feb 20, 5pm (Africa/Libreville)'"
    - "Event payload contains resetTime as a Date for unix timestamp format"
    - "Event payload contains resetTime as a Date for human-readable time format"
    - "Event payload contains resetTime: null when timestamp cannot be parsed from a custom pattern match"
    - "Detector matches after ANSI escape codes are stripped from input"
    - "Detector matches when the message is split across two feed() calls"
    - "Detector uses custom pattern from constructor option instead of default"
    - "Detector uses pattern from config file when no constructor option given"
    - "Detector does not double-emit after first detection (guarded by #detected flag)"
    - "Detector re-arms after reset() and can detect again"
    - "Debug mode logs buffer contents to stderr"
    - "Rolling buffer trims to 4KB when exceeded"
  artifacts:
    - path: "src/PatternDetector.ts"
      provides: "EventEmitter subclass with rolling buffer, ANSI stripping, regex matching, timestamp parsing"
      exports: ["PatternDetector", "LimitEvent"]
      min_lines: 80
    - path: "test/PatternDetector.test.ts"
      provides: "Comprehensive unit tests for all detection scenarios"
      min_lines: 100
  key_links:
    - from: "src/PatternDetector.ts"
      to: "src/config.ts"
      via: "import { loadConfig } from './config.js'"
      pattern: "import.*loadConfig.*config"
    - from: "src/PatternDetector.ts"
      to: "strip-ansi"
      via: "import stripAnsi from 'strip-ansi'"
      pattern: "import.*strip-ansi"
    - from: "src/PatternDetector.ts"
      to: "events"
      via: "extends EventEmitter"
      pattern: "extends EventEmitter"
---

<objective>
Build the PatternDetector class using TDD — the core detection engine that identifies rate-limit messages in PTY output, strips ANSI codes, handles chunk splitting via a rolling buffer, parses reset timestamps, and emits structured events.

Purpose: This is the heart of the entire tool. If the detector does not fire, nothing else matters. TDD ensures every format variant and edge case is covered before the implementation is considered done.
Output: Fully tested PatternDetector class with all three format variants, ANSI handling, buffer management, and configurable patterns.
</objective>

<execution_context>
@/Users/dakmor/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dakmor/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-detection-engine/01-RESEARCH.md
@.planning/phases/01-detection-engine/01-01-SUMMARY.md

<interfaces>
<!-- From Plan 01 — config loader interface that PatternDetector depends on -->

From src/config.ts:
```typescript
export interface ToolConfig {
  pattern?: RegExp;
}

export const CONFIG_PATH: string; // join(homedir(), '.config', 'claude-auto-continue', 'config.json')

export function loadConfig(): ToolConfig;
```
</interfaces>
</context>

<feature>
  <name>PatternDetector — Rate-Limit Detection Engine</name>
  <files>src/PatternDetector.ts, test/PatternDetector.test.ts</files>
  <behavior>
PatternDetector is an EventEmitter subclass. It exposes:
- `constructor(options?: { pattern?: RegExp; debug?: boolean })` — loads config, sets pattern (constructor > config > default)
- `feed(rawChunk: string): void` — strips ANSI, appends to rolling buffer (4KB max), runs regex, emits 'limit' if matched
- `reset(): void` — clears buffer and re-arms detection
- Event: `'limit'` with payload `{ resetTime: Date | null, rawMatch: string }`

**Three known rate-limit message formats (default regex must match ALL):**

Format A (legacy): `"Claude AI usage limit reached|1760000400"`
- Pipe-delimited with unix timestamp (seconds)
- resetTime: `new Date(1760000400 * 1000)`

Format B (mid-2025): `"Claude usage limit reached. Your limit will reset at 3pm (America/Santiago)."`
- Human-readable time with timezone in parens
- resetTime: parsed from "3pm" → today or tomorrow if past

Format C (current): `"You've hit your limit · resets 4pm (Europe/Berlin)"`
- Middle dot separator, "resets" keyword
- Variant with date: `"You've hit your limit · resets Feb 20, 5pm (Africa/Libreville)"`
- resetTime: parsed from "4pm" or "5pm"

**Edge cases:**
- ANSI codes embedded: `"\x1b[1mYou've hit your limit\x1b[0m · resets 4pm (UTC)"` → must match after stripping
- Chunk split: first feed `"You've hit your "`, second feed `"limit · resets 3pm (UTC)"` → must match on second feed
- Custom pattern: `new PatternDetector({ pattern: /CUSTOM/ })` → matches only CUSTOM, not defaults
- Double feed after detection: second feed ignored (no double-emit)
- Reset + re-detect: after `reset()`, same message triggers again
- Unparseable time: custom pattern match with no timestamp info → `resetTime: null`
- Buffer overflow: feed >4KB of data → buffer trimmed to last 4KB
- Day rollover: "resets 2am" when current time is 11pm → parsed as tomorrow 2am, not today (past)
  </behavior>
  <implementation>
Follow TDD RED-GREEN-REFACTOR cycle from RESEARCH.md Code Examples section.

**RED phase:** Write test/PatternDetector.test.ts with all test cases listed above. Tests import PatternDetector. Run tests — all fail (class doesn't exist yet).

**GREEN phase:** Implement src/PatternDetector.ts:
1. Extend EventEmitter
2. Constructor: call `loadConfig()` from `./config.js`, merge with constructor options (constructor wins)
3. `feed()`: strip ANSI via `stripAnsi()`, append to `#buffer`, trim if >4096 chars, test regex, emit on match
4. Timestamp parsing: try unix timestamp regex first (`/\|(\d{10,})/`), then human-readable regex (`/resets?\s+(?:\w+\s+\d{1,2},?\s*)?(\d{1,2}(?::\d{2})?\s*[ap]m)\s*\(([^)]+)\)/i`)
5. Human time parsing: extract hours/minutes/meridiem, build Date, roll to tomorrow if in past
6. `#detected` guard: set true on first match, `feed()` returns early if true
7. `reset()`: clear buffer + detected flag
8. Debug mode: if `options.debug`, write buffer snapshot to stderr on each `feed()`

Default regex pattern (must match all three formats):
```
/(?:Claude(?:\s+AI)?\s+usage\s+limit\s+reached[|.]|you(?:'ve| have)\s+hit\s+your\s+limit)/i
```

Run tests — all pass.

**REFACTOR phase:** Clean up if needed, ensure no duplication, run tests again.

**Important implementation notes:**
- Use `import stripAnsi from 'strip-ansi'` (default import, CJS interop with esModuleInterop)
- Use `import { loadConfig } from './config.js'` (the .js extension is needed for TypeScript CJS module resolution)
- `rawMatch` in the event payload should be the last ~500 chars of the buffer (provides context around the match)
- The `#parseHumanTime` method does NOT need full IANA timezone resolution — parse hour/minute/meridiem only, trust local clock per user decision
- Mock `loadConfig` in tests using `vi.mock('./config.js')` to control config values
  </implementation>
</feature>

<verification>
1. `npx vitest run test/PatternDetector.test.ts` — all tests pass
2. `npx tsc --noEmit` — no type errors
3. Tests cover: all 3 format variants, ANSI stripping, chunk splitting, custom pattern, double-emit guard, reset re-arm, null resetTime, buffer overflow, debug mode
</verification>

<success_criteria>
- PatternDetector detects all three known rate-limit message formats
- ANSI escape codes are stripped before matching
- Rolling buffer handles message split across chunks
- Custom pattern via constructor overrides default
- Config file pattern used when no constructor option
- No double-emission after first detection
- reset() re-arms for next detection cycle
- resetTime is Date for parseable timestamps, null for unparseable
- All tests pass without spawning any process or PTY
</success_criteria>

<output>
After completion, create `.planning/phases/01-detection-engine/01-02-SUMMARY.md`
</output>
