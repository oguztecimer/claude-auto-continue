---
phase: 01-detection-engine
plan: 03
type: tdd
wave: 2
depends_on:
  - 01-01
files_modified:
  - src/Scheduler.ts
  - test/Scheduler.test.ts
autonomous: true
requirements:
  - DETC-02
must_haves:
  truths:
    - "Scheduler fires callback after resetTime + safetyBuffer milliseconds from now"
    - "Scheduler fires callback immediately (via setTimeout 0) when resetTime is in the past"
    - "Scheduler does not fire callback after cancel() is called"
    - "Scheduler handles null resetTime by firing immediately as a fallback"
    - "Scheduler clears previous timer when scheduleAt() is called again before firing"
    - "Safety buffer defaults to 5 seconds and is configurable via constructor"
  artifacts:
    - path: "src/Scheduler.ts"
      provides: "Wall-clock anchored setTimeout wrapper with safety buffer and cancel support"
      exports: ["Scheduler"]
      min_lines: 30
    - path: "test/Scheduler.test.ts"
      provides: "Unit tests using vitest fake timers — no real time waits"
      min_lines: 50
  key_links:
    - from: "src/Scheduler.ts"
      to: "global setTimeout/clearTimeout"
      via: "setTimeout for scheduling, clearTimeout for cancel"
      pattern: "setTimeout|clearTimeout"
---

<objective>
Build the Scheduler class using TDD — a wall-clock anchored setTimeout wrapper that fires a callback at `resetTime + safetyBuffer`, handles past times by firing immediately, and supports cancellation for clean shutdown.

Purpose: The Scheduler is the bridge between detecting a rate limit (Phase 1) and resuming a session (Phase 2). It ensures the resume action happens at the right time — not too early (before the limit resets) and not too late (wasting time). Testing with fake timers proves correctness without real multi-hour waits.
Output: Fully tested Scheduler class with wall-clock anchoring, safety buffer, immediate fallback, and cancel support.
</objective>

<execution_context>
@/Users/dakmor/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dakmor/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-detection-engine/01-RESEARCH.md
</context>

<feature>
  <name>Scheduler — Wall-Clock Anchored Timer</name>
  <files>src/Scheduler.ts, test/Scheduler.test.ts</files>
  <behavior>
Scheduler is a plain class (not an EventEmitter). It exposes:
- `constructor(safetyBufferMs?: number)` — defaults to 5000 (5 seconds)
- `scheduleAt(resetTime: Date | null, callback: () => void): void` — calculates waitMs, sets setTimeout
- `cancel(): void` — clears timer, prevents callback from firing

**Timing logic:**
- `waitMs = Math.max(0, resetTime.getTime() - Date.now() + safetyBufferMs)`
- If resetTime is null → fire immediately (setTimeout with 0ms) as fallback behavior
- If resetTime is in the past → waitMs clamps to 0 (plus safety buffer, which may still be >0, then clamp again: `Math.max(0, ...)`)
- If cancel() called before timer fires → callback never runs

**Re-scheduling:**
- Calling scheduleAt() while a timer is pending cancels the old timer and sets a new one
- After cancel(), the scheduler is inert — calling scheduleAt() after cancel() should NOT schedule (the `#cancelled` flag stays true)

**Edge cases:**
- resetTime exactly now: waitMs = safetyBufferMs (fires after safety buffer only)
- resetTime far in future (3 hours): single setTimeout handles it (no setInterval drift)
- Multiple scheduleAt calls: only last one active
- cancel() when no timer pending: no-op, no error
  </behavior>
  <implementation>
Follow TDD RED-GREEN-REFACTOR cycle from RESEARCH.md Code Examples section.

**RED phase:** Write test/Scheduler.test.ts with all test cases. Use `vi.useFakeTimers()` in beforeEach and `vi.useRealTimers()` in afterEach. Tests import Scheduler. Run tests — all fail.

Test cases:
1. Fires callback after calculated wait + safety buffer (60s future + 5s buffer = fires at ~65s)
2. Fires callback immediately when resetTime is in the past (clamps to 0 + safety buffer)
3. Does not fire callback after cancel()
4. Handles null resetTime by firing immediately (0ms delay)
5. Re-scheduling cancels previous timer (only last callback fires)
6. cancel() when no timer pending does not throw
7. scheduleAt() after cancel() does not schedule (cancelled flag stays true)
8. Safety buffer is configurable via constructor (e.g., 10000ms instead of default 5000ms)

Use `vi.advanceTimersByTimeAsync()` to advance fake timers.

**GREEN phase:** Implement src/Scheduler.ts:
```typescript
export class Scheduler {
  #timer: ReturnType<typeof setTimeout> | null = null;
  #cancelled = false;
  readonly #safetyMs: number;

  constructor(safetyMs = 5000) {
    this.#safetyMs = safetyMs;
  }

  scheduleAt(resetTime: Date | null, callback: () => void): void {
    if (this.#cancelled) return;

    // Clear any existing timer
    if (this.#timer) {
      clearTimeout(this.#timer);
      this.#timer = null;
    }

    const waitMs = resetTime
      ? Math.max(0, resetTime.getTime() - Date.now() + this.#safetyMs)
      : 0;

    this.#timer = setTimeout(() => {
      if (!this.#cancelled) callback();
    }, waitMs);
  }

  cancel(): void {
    this.#cancelled = true;
    if (this.#timer) {
      clearTimeout(this.#timer);
      this.#timer = null;
    }
  }
}
```

Run tests — all pass.

**REFACTOR phase:** Clean up if needed, run tests again.

**Important implementation notes:**
- Use `Date.now()` at schedule time — this anchors the wait to wall-clock time, not a decrementing counter
- Do NOT use `setInterval` — timer drift compounds over multi-hour waits
- The `#cancelled` flag prevents the callback from firing even if clearTimeout races with the timer
- safetyBufferMs of 5 seconds is per user decision ("a few seconds") — this is within Claude's discretion
  </implementation>
</feature>

<verification>
1. `npx vitest run test/Scheduler.test.ts` — all tests pass
2. `npx tsc --noEmit` — no type errors
3. Tests use fake timers exclusively — no real time waits, test suite completes in <1 second
4. Tests cover: future time, past time, null time, cancel, re-schedule, configurable buffer
</verification>

<success_criteria>
- Scheduler fires at resetTime + safetyBuffer (wall-clock anchored)
- Past reset times fire immediately (clamped to 0)
- Null reset times fire immediately as fallback
- cancel() prevents callback from firing
- Re-scheduling cancels previous timer
- No setInterval usage — single setTimeout only
- All tests pass with fake timers, no real waits
</success_criteria>

<output>
After completion, create `.planning/phases/01-detection-engine/01-03-SUMMARY.md`
</output>
